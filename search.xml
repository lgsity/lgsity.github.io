<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><p>正则表达式对复杂的文本处理具有灵活简洁的优势，正则不仅仅在Java中有，大部分的编程语言、数据库、文本编辑器、开发环境都支持正则表达式，但是在不同环境下可能会有略微不同。在前端正则表达式经常用作校验用户输入的数据是否符合要求。</p><p>正则表达式就是描述了一个规则，通过这个规则可以匹配一类字符串。学习正则表达式很大程度上就是学习它的<strong>语法规则</strong></p><h2 id="开发中使用正则表达式的流程"><a href="#开发中使用正则表达式的流程" class="headerlink" title="开发中使用正则表达式的流程"></a>开发中使用正则表达式的流程</h2><ol><li>分析要匹配的数据，写出对应的正则表达式</li><li>在工具软件中进行匹配测试，设置一些典型数据或者边界值或者是自己不确定是否能匹配到的值；也可以另外写段代码进行测试。</li><li>在程序中调用通过测试的正则表达式。</li></ol><h2 id="语法（1）"><a href="#语法（1）" class="headerlink" title="语法（1）"></a>语法（1）</h2><ul><li><p><strong>普通字符</strong></p><p>字母、数字、汉字、下划线以及没有特殊定义的标点符号都是<strong>“普通字符”</strong>。表达式中的普通字符在匹配一个字符串时，匹配与之相同的一个字符串（比如表达式<code>a2你_!</code>意为匹配<code>a2你_!</code>这个字符串）。</p></li><li><p><strong>简单的转义字符</strong></p><p><img src="http://q1oi1oc62.bkt.clouddn.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%951.png" alt=""></p></li></ul><h2 id="语法（2）"><a href="#语法（2）" class="headerlink" title="语法（2）"></a>语法（2）</h2><ul><li><p><strong>标准字符集合</strong></p><p>——能够与‘多种字符’匹配的表达式</p><p>——<strong>注意区分大小写，大写与小写意思相反，比如\D表示除0~9以外的任何字符</strong></p><table><thead><tr><th align="center">\d</th><th align="center">任意一个0~9的数字</th></tr></thead><tbody><tr><td align="center">\w</td><td align="center">任意一个字母或数字或下划线，即A<del>Z,a</del>z,0~9,_中的任意一个</td></tr><tr><td align="center">\s</td><td align="center">空格、制表符、换行符等空白字符中的任意一个</td></tr><tr><td align="center">.</td><td align="center">小数点匹配除<strong>“\n”</strong>外的所有字符，匹配所有字符一般用<strong>[\s\S]</strong></td></tr></tbody></table><p>[\s\S] 中间相当于有一个或，就是取\s或者\S，\s 取空格、制表符、换行符等空白字符中的任意一个，\S取所有字符去掉\s，所以就取到了所有字符。</p></li></ul><h2 id="语法（3）"><a href="#语法（3）" class="headerlink" title="语法（3）"></a>语法（3）</h2><ul><li><p><strong>自定义字符集合</strong>    </p><p>——[]中括号匹配方式，能够匹配中括号内部的<strong>任意一个</strong>字符</p><table><thead><tr><th align="center">[ab5@]</th><th align="center">匹配“a”或者“b”或者“5”或者“@”</th></tr></thead><tbody><tr><td align="center">[^abc]</td><td align="center">匹配“a”,”b”,”c”<strong>之外</strong>的任意一个字符</td></tr><tr><td align="center">[f-k]</td><td align="center">匹配”f”到”k”之间的任意一个字符（包括f和k）</td></tr><tr><td align="center">[^F-K2-5]</td><td align="center">匹配“F”-“K”,”2”-“5”之外的任意一个字符</td></tr></tbody></table><p>——正则表达式的特殊符号被包括在中括号中则失去特殊意义（比如$在中括号中只表示普通字符”$”），除了    ^,-之外。</p><p>——标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。比如：</p><p>[\d.\-+]将匹配：数字、小数点、+、-</p></li></ul><h2 id="语法（4）"><a href="#语法（4）" class="headerlink" title="语法（4）"></a>语法（4）</h2><ul><li><p><strong>量词</strong></p><p>——修饰匹配字符的次数</p><table><thead><tr><th align="center">{n}</th><th align="center">表达式出现n次</th></tr></thead><tbody><tr><td align="center">{m,n}</td><td align="center">表达式出现最少m次，最多n次</td></tr><tr><td align="center">{m,}</td><td align="center">表达式出现最少m次</td></tr><tr><td align="center">?</td><td align="center">等价于{0,1}，不出现或者出现一次</td></tr><tr><td align="center">+</td><td align="center">表达式至少出现一次，等价于{1,}</td></tr><tr><td align="center">*</td><td align="center">不出现或者任意次，等价于{0,}</td></tr></tbody></table><p>——匹配次数中的<strong>贪婪模式</strong>（匹配字符越多越好，默认！）</p><p>​    比如：表达式：\d{2,3}   样例：12345678  结果：匹配到123, 456, 78</p><p>——<strong>非贪婪模式</strong>（匹配字符越少越好，在表示匹配次数的特殊符号后再加上一个”?”）</p><p>​    比如：表达式：\d{2,3}？   样例：12345678  结果：匹配到12, 34, 56, 78</p><p><strong>注意</strong></p><p>​    \d\d{3}  :  表示匹配4个数字</p><p>​    (\d\d){3}  :  表示匹配6个数字</p></li></ul><h2 id="语法（5）"><a href="#语法（5）" class="headerlink" title="语法（5）"></a>语法（5）</h2><ul><li><p><strong>字符边界</strong></p><p>——（本组标记匹配的不是字符而是位置，符合某种条件的位置）</p><table><thead><tr><th align="center">^</th><th align="center">与字符串开始的地方匹配</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">与字符串结束的地方匹配</td></tr><tr><td align="center">\b</td><td align="center">匹配一个单词边界</td></tr></tbody></table><p>—— \b 匹配这样一个位置：前面的字符和后面的字符不全是\w（字母，数字，下划线）</p><p>​    ysl\b  :  能匹配123ysl,ysl,ysl$不能匹配123ysl123,yslzz,ysl_</p><p>​    ^y  :  <strong>y</strong>sl   rugnjvv y匹配这个字符串开始的位置，如果是sl   rugnjvv y就匹配不到</p><p>​        <strong>注意：^在中括号中是取反的意思</strong></p><p>​    y$  :  ysl   rugnjvv <strong>y</strong>匹配这个字符串开始的位置，如果是ysl   rugnjvv 就匹配不到</p></li></ul><h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><ul><li><p><strong>IGNORECASE忽略大小写模式</strong></p><p>——匹配时忽略大小写。</p><p>——默认情况下，正则表达式是区分大小写的。比如ysl只匹配ysl，不匹配YSL，开启忽略大小写模式后两者都能匹配到。</p></li><li><p><strong>SINGLELINE单行模式</strong></p><p>——整个文本看作一个字符串，只有一个开头和结尾。</p><p><strong>——使小数点“.”可以匹配包含换行符（\n）在内的任意字符。</strong>（注意区别标准字符集合中小数点）</p></li><li><p><strong>MULTILINE多行模式</strong></p><p>——每行都是一个字符串，都有开头和结尾</p><p>——在指定了MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\A和\Z。</p><p>​    \Ay  :  匹配第一行开始位置y，如果第一行开始位置不是y就不匹配</p><p>​    y\Z  :  匹配最后一行结束位置的y，如果最后一行结束位置不是y就不匹配</p></li></ul><h2 id="语法（6）"><a href="#语法（6）" class="headerlink" title="语法（6）"></a>语法（6）</h2><ul><li><p><strong>选择符和分组</strong></p><table><thead><tr><th align="center">表达式</th><th>作用</th></tr></thead><tbody><tr><td align="center">|（分支结构）</td><td>左右两边表达式之间“或”关系，匹配左边或者右边</td></tr><tr><td align="center">()捕获组</td><td>(1)在被修饰匹配次数时，括号中的表达式可以作为整体被修饰<br>(2)取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3)每一对括号会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td align="center">(?:Expression)非捕获组</td><td>一些表达式中，不得不使用(),但是又不需要保存()中子表达式匹配的内容，这时可以用非捕获组来抵消使用()带来的副作用（在处理大量文本时，保存会消耗大量内存）</td></tr></tbody></table></li><li><p><strong>反向引用（\nnn）</strong></p><p>-每一对()会分配一个编号，使用()的捕获根据<strong>左括号的顺序</strong>从1开始自动编号。</p><p>-通过反向引用，可以对分组<strong>已捕获的字符串</strong>进行引用</p><p>比如([a-z]{2})\1对字符串”abcd  ababb dbdbdb”匹配到”abab”,”dbdb”。意思是a-z任意2个字母作为捕获组，再引用一次</p><p>(?:[a-z]{2})不影响([a-z]{2})表达的意思，只是匹配的内容不会存起来，就无法进行引用，(?:[a-z]{2})\1这个表达式将无效</p></li></ul><h2 id="语法（7）"><a href="#语法（7）" class="headerlink" title="语法（7）"></a>语法（7）</h2><ul><li><p><strong>预搜索（零宽断言）</strong></p><p>——只进行子表达式的匹配，匹配内容不计入最终结果，是零宽度</p><p>——这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但是不匹配前后的字符，是<strong>对位置的匹配</strong>。</p><p>——正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是<strong>占有字符</strong>的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，取决于匹配的内容是否保存到最终匹配结果中。</p><table><thead><tr><th align="center">(?=Expression)</th><th align="center">断言自身出现的位置的<strong>后面能</strong>匹配表达式Expression</th></tr></thead><tbody><tr><td align="center">(?&lt;=Expression)</td><td align="center">断言自身出现的位置的<strong>前面能</strong>匹配表达式Expression</td></tr><tr><td align="center">(?!Expression)</td><td align="center">断言自身出现的位置的<strong>后面不能</strong>匹配表达式Expression</td></tr><tr><td align="center">(?&lt;!Expression)</td><td align="center">断言自身出现的位置的<strong>前面不能</strong>匹配表达式Expression</td></tr></tbody></table><p>[a-z]+(?=ing):对于字符串”acount going running”匹配结果为”go”,”runn”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2019/11/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2019/11/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="对Java虚拟机的理解"><a href="#对Java虚拟机的理解" class="headerlink" title="对Java虚拟机的理解"></a>对Java虚拟机的理解</h3><p> JVM是Java Virtual Machine（Java虚拟机）的缩写 ，是执行字节码文件（.class）的虚拟机进程。</p><p>java源程序（.java）被编译器编译成字节码文件（.class）,然后Java虚拟机将字节码文件解释成机器码（不同平台的机器码不同），这就是Java虚拟机的基本定义和作用。</p><h3 id="java被称作与平台无关的语言"><a href="#java被称作与平台无关的语言" class="headerlink" title="java被称作与平台无关的语言"></a>java被称作与平台无关的语言</h3><p>Java虚拟机可以将字节码文件编译成该平台对应的机器码，而不需要程序员对运行在不同平台的java程序另外修改代码，也不需要重新编译。真正实现一次编译，到处运行。java虚拟机知道底层硬件平台的指令长度和其他特性</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建自己的hexo博客教程</title>
      <link href="/2019/11/28/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/28/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Git和node-js"><a href="#安装Git和node-js" class="headerlink" title="安装Git和node.js"></a>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>和<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a></h2><p>直接进入官网或者点击我上面的链接，下载对应的Windows系统版本，然后直接安装。检验是否成功：打开cmd，输入<code>node -v</code>,有版本号出来说明node.js安装成功，在桌面鼠标右击，有Git Bash Here选项说明安装成功。</p><h2 id="安装hexo客户端"><a href="#安装hexo客户端" class="headerlink" title="安装hexo客户端"></a>安装hexo客户端</h2><p>在你电脑D盘或别的盘，新建个目录如hexo，回到桌面，右击打开Git Bash Here,这是一个类似Linux终端的界面，保证在你新建的目录下执行<code>npm install -g hexo-cli</code>命令，安装hexo客户端，然后执行<code>hexo init blog</code>,blog是自定义的，会生成这个目录，操作过程如下</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128104501240.png" alt=""></p><h2 id="安装npm（-Node-Package-包-Manager-管理器-）"><a href="#安装npm（-Node-Package-包-Manager-管理器-）" class="headerlink" title="安装npm（ Node Package(包) Manager(管理器)）"></a>安装npm（ Node Package(包) Manager(管理器)）</h2><p>先进入刚刚生成的目录blog，再执行<code>npm install</code>，如果输出信息有提示你 <strong>use npm audit fix –force to install breaking changes; or refer to npm audit for steps to fix these manually)</strong> 那么你再执行一下<code>npm audit fix</code> 检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖 ,如果没有提示则不必执行。（你要是不清楚是否需要执行就执行一下，反正这条命令也是检测环境的命令）像我下面就没有出现提示</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128105618030.png" alt=""></p><h2 id="完成搭建"><a href="#完成搭建" class="headerlink" title="完成搭建"></a>完成搭建</h2><p>执行<code>hexo generate</code>或者缩写<code>hexo g</code>,生成静态博客</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128105917349.png" alt=""></p><p>执行<code>hexo serve</code>或者缩写<code>hexo s</code>,启动服务</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128110056206.png" alt=""></p><p>正常启动后，打开浏览器，地址栏访问localhost:4000,就可以看到hexo的默认页面</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128110333384.png" alt=""></p><p>在git bash下Ctrl+C关闭hexo server</p><h2 id="托管到github仓库"><a href="#托管到github仓库" class="headerlink" title="托管到github仓库"></a>托管到github仓库</h2><p>你要有一个github的账号，然后新建一个空的存储库，<strong>注意：你存储库的名字必须是</strong><code>xxxxx.github.io</code>,xxxxx就是你的github用户名，然后回到git bash安装deployer-git,这是用来将你的博客推送到github仓库的工具，执行<code>npm install hexo-deployer-git</code>，这是在blog下执行，不是在hexo</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128111747192.png" alt=""></p><p>然后去本地修改_config.yml文件，</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128112005016.png" alt=""></p><p>找到deploy配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yslinzz/abc.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><strong>注意：每一个冒号后面要有一个空格，repo是刚刚你自己建的那个空的仓库的地址，如下图（我这里abc命名是随便写的，与前面冲突，不要在意）</strong></p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128112647499.png" alt=""></p><p>然后执行<code>hexo clean</code>清理一下，再执行<code>hexo generate</code>或者<code>hexo g</code> 生成静态博客系统 ,最后执行<code>hexo deploy</code>或者缩写<code>hexo d</code>将博客系统推送到GitHub并发布</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128113444910.png" alt=""></p><p>成功后，你在GitHub仓库刷新就会有你的博客系统，此时你在地址栏访问刚刚在_config.yml中配置的repo就可以访问到你的博客了</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128113800406.png" alt=""></p><p>至此，你的个人博客就搭建并发布完成，后续你可以找一个漂亮的主题，然后在上面记录你的点点滴滴，有问题可以在<a href="https://yuanshulin.com/">我的博客</a>下留言，或者Email我，</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
