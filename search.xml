<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础（一）</title>
      <link href="/2019/12/01/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/12/01/Java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Java中如何跳出当前的多重嵌套循环"><a href="#Java中如何跳出当前的多重嵌套循环" class="headerlink" title="Java中如何跳出当前的多重嵌套循环"></a>Java中如何跳出当前的多重嵌套循环</h2><ul><li><p>可以用带标签的break语句跳出，但是在Java中应该避免使用带标签break和continue语句，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好</p><pre><code class="java">package basis;/** * 跳出多重嵌套循环 * @author shulinYuan Email:2762954662@qq.com * */public class Demo01 {    public static void main(String[] args) {        method1();        method2();    }    //定义标号，break退出    public static void method1() {        out://外层循环定义标号            for(int i=0;i&lt;10;i++) {                for(int j=0;j&lt;10;j++) {                    System.out.println(&quot;i=&quot;+i+&quot;,j=&quot;+j);                    if(j==6)                        break out;//使用标号                }            }    }    //让外层循环受到内层循环的控制    public static void method2() {        boolean flag = false;        for(int i=0;i&lt;10&amp;&amp;!flag;i++) {            for(int j=0;j&lt;10;j++) {                System.out.println(&quot;i=&quot;+i+&quot;,j=&quot;+j);                if(j==6) {                    flag = true;//内层控制外层                    break;//跳出内层循环                }            }        }    }}</code></pre></li><li><p><strong>break和continue的区别</strong>(觉得<a href="https://blog.csdn.net/Baronrothschlid/article/details/88936277" target="_blank" rel="noopener">这个</a>很形象，就摘抄过来了)</p><p>假设有10个人参加面试，现在进行到第三个人了，突然，面试官有事了，需要走，那么今天剩下这些人就没有办法继续面试了，显然面试整个结束了。(break)</p><p>假设有10个人参加面试，现在进行到第三个人了，面试官想要招聘一位女生做秘书，但是这第三个人是一位男士，面试官说：今天咱们就聊到这里吧，下一位。（continue）</p></li></ul><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp;和&amp;&amp;的区别"></a>&amp;和&amp;&amp;的区别</h2><ul><li><p>&amp;有按位与和逻辑与，按位与就是把两个数都转化成二进制，然后<strong>逐位相与</strong>，比如下面的5&amp;6，就是00000101和00000110相与，结果为00000100，即4；逻辑与&amp;是<strong>非短路与</strong>，就是所有条件都会判断，<strong>短路与</strong>&amp;&amp;就是判断到当前条件不符合就不会再判断剩下的条件，测试代码如下：</p><pre><code class="java">package basis;/** * &amp;与&amp;&amp;的区别 * @author shulinYuan Email:2762954662@qq.com * */public class Demo02 {    public static void main(String[] args) {        //按位与&amp;        int x = 5 &amp; 6;        System.out.println(x);//x=4        int a = 1;        int b = 2;        try {            //非短路与&amp;            if(a&gt;b &amp; a&lt;b/0)                System.out.println(&quot;不可能输出&quot;);        }catch (ArithmeticException e) {            System.out.println(&quot;非短路与&amp;就是所有条件都会判断，所以这里会报错，然后输出我。&quot;);        }        //短路与&amp;&amp;        if(a&gt;b &amp;&amp; a&lt;b/0) {            System.out.println(&quot;不可能输出&quot;);        }else {            System.out.println(&quot;短路与&amp;&amp;就是当条件不满足时，后面的条件不会再判断，所以这里不会报错&quot;);        }    }}</code></pre></li></ul><h2 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h2><ul><li><p>最主要的区别就是int是基本数据类型，Integer是int的包装类，用<strong>面向对象的思想</strong>去看Integer，Java是一个近乎纯洁的面向对象编程语言，但是为了编程方便还是引入了基本数据类型，但是为了能把这些数据类型当作对象操作，Java为每一个基本数据类型都引入了对应的包装类型，从Java5开始引入了<strong>自动装/拆箱</strong>机制，使得二者可以相互转换。</p></li><li><p>装箱就是把int转成Integer对象，拆箱与之相反；对象缺省值是null，基本数据类型缺省值和类型有关，Integer缺省值是null，int缺省值是0。</p><pre><code class="java">package basis;/** * 自动装箱，拆箱 * @author shulinYuan Email:2762954662@qq.com * */public class Demo03 {    public static void main(String[] args) {        Integer a = 5;//自动装箱        Integer b = new Integer(5);        int c = 5;        System.out.println(a==b);//false,a,b为两个不同的对象        System.out.println(a==c);//true,a自动拆箱成int类型与c比较    }}</code></pre></li><li><p>——原始类型：byte, int, long, float, double, short, char, boolean</p><p>——包装类型：Byte, Integer, Long, Float, Double, Short, Character, Boolean</p></li></ul><h2 id="如何输出一个某种编码的字符串"><a href="#如何输出一个某种编码的字符串" class="headerlink" title="如何输出一个某种编码的字符串"></a>如何输出一个某种编码的字符串</h2><ul><li><p>字符串先调用getBytes(String charsetName)（参数为当前字符串的编码格式）转换成字节数组，再将此字节数组和要转换成的字节编码一起作为参数传入String类的构造方法中，即可生成指定编码的字符串，测试代码如下：</p><pre><code class="java">package basis;/** * 输出指定编码字符串 * @author shulinYuan Email:2762954662@qq.com * */public class Demo04 {    public static void main(String[] args) {        String str = &quot;abcd&quot;;        String tempStr = &quot;&quot;;         try {         tempStr = new String(str.getBytes(&quot;utf-8&quot;), &quot;unicode&quot;);         tempStr = tempStr.trim();//trim() 方法用于删除字符串的头尾空白符。         }         catch (Exception e) {         System.err.println(e.getMessage());         }         System.out.println(tempStr);//慢捤    }}</code></pre></li></ul><h2 id="String-和StringBuffer的区别"><a href="#String-和StringBuffer的区别" class="headerlink" title="String 和StringBuffer的区别"></a>String 和StringBuffer的区别</h2><ul><li><p>String类是final的，不可修改的，只要改动了那就一定不是原来的对象，StringBuffer类拥有很多修改的方法，最重要的是不需要创建新的对象。String使用+拼接字符串时，一定要找一个新的更大的内存来存储，这是非常耗时的，而StringBuffer是预先就分配了指定长度的内存空间，不需要频繁分配内存，所以操作经常需要修改的字符串还是使用StringBuffer效率更高。</p><pre><code class="java">package basis;/** * String和StringBuffer区别 * @author shulinYuan Email:2762954662@qq.com * */public class Demo05 {    public static void main(String[] args) {        StringBuffer sb1 = new StringBuffer();//分配16字节字符缓冲区        StringBuffer sb2 = new StringBuffer(1024);//分配1024字节字符缓冲区        StringBuffer sb = new StringBuffer(&quot;I&#39;m better!&quot;);        //追加方法        sb.append(&quot;yes&quot;);        System.out.println(sb);//I&#39;m better!yes        //指定位置删除,从0开始        sb.deleteCharAt(1);        System.out.println(sb);//Im better!yes        //删除一定范围位置的字符，包括开始位置，不包括结束位置        sb.delete(0, 7);        System.out.println(sb);//er!yes        //在指定位置插入字符串        sb.insert(6, &quot;hello&quot;);        System.out.println(sb);//er!yeshello        //反向方法：将字符串内容反转，形成新的字符串        sb.reverse();        System.out.println(sb);//ollehsey!re        //替换指定位置字符        sb.setCharAt(6, &#39;A&#39;);        System.out.println(sb);//ollehsAy!re        //替换指定位置字符串        sb.replace(0, 3, &quot;Hello&quot;);        System.out.println(sb);//HelloehsAy!re    }}</code></pre></li></ul><h2 id="String不是最基本的数据类型"><a href="#String不是最基本的数据类型" class="headerlink" title="String不是最基本的数据类型"></a>String不是最基本的数据类型</h2><ul><li>Java中只有8大基本数据类型(primitive type)，除此之外都是引用类型(reference type),枚举类型（enumeration type）也是引用类型。</li><li>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。</li><li>byte(1个字节),int(4个字节),long(8个字节),float(4个字节),doublelong(8个字节),char(2个字节),boolean(理论上占用1bit,1/8字节，实际处理按1byte处理) ,short(2个字节)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式练习</title>
      <link href="/2019/11/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/11/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="电话号码验证"><a href="#电话号码验证" class="headerlink" title="电话号码验证"></a>电话号码验证</h2><ul><li><p><strong>要求</strong></p><ol><li>固定电话：如果有区号，那么区号可以是3位或者4位，首位必须是0，电话号码为7位到8位，区号与电话号码之间用“-”连接，如果没有区号，电话号码为7位到8位。</li><li>移动电话：11位，第一第二位为“13”，“15”，“18”三者之一。</li></ol></li><li><p><strong>我的思路</strong></p><ol><li>先求不含区号的固定电话正则表达式：\d{7,8}</li><li>再求含区号的：0\d{2,3}-\d{7,8}</li><li>移动的：1[358]\d{9}</li><li>最后把他们用或连接：(\d{7,8})|(0\d{2,3}-\d{7,8})|(1[358]\d{9})</li></ol><p>过程中我以为表示或需要转义，使用的是\|,导致验证出错，这里再次提醒自己，|表示“或”的意思，\|单纯得表示“|”字符，没有特殊含义。</p></li><li><p><strong>验证</strong></p><pre><code class="java">package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Telephone {    public static void main(String[] args){         //需要验证的手机号        String tel=&quot;12631721765&quot;;        //正则表达式        String reg =&quot;(0\\d{2,3}-\\d{7,8})|(\\d{7,8})|(1[358]\\d{9})&quot; ;          //编译正则表达式         Pattern pattern = Pattern.compile(reg);        Matcher matcher = pattern.matcher(tel);        // 字符串是否与正则表达式相匹配        boolean rs = matcher.matches();        System.out.println(rs);                                 }}</code></pre></li></ul><h2 id="邮箱验证"><a href="#邮箱验证" class="headerlink" title="邮箱验证"></a>邮箱验证</h2><ul><li><p><strong>要求</strong></p><ol><li>用户名：字母、数字、中划线、下划线组成</li><li>@</li><li>网址：字母、数字组成</li><li>小数点：.</li><li>组织域名：2-4位字母组成</li></ol></li><li><p><strong>我的思路</strong></p><p>这个邮箱的话直接匹配，就是一条条规则去满足，用户名：[\w-]+,到@：[\w-]+@,到网址：[\w-]+@[A-Za-z0-9]+，到小数点，这里小数点和组织域名应该看成一个组合，因为有的会有.org.cn这样两组的，所以到小数点和组织域名：[\w-]+@[A-Za-z0-9]+(\.[A-Za-z]{2,4}){1,2}</p></li><li><p><strong>验证</strong></p><p>可以采用专门的正则表达式的软件工具验证，也可以用我上面那段代码验证</p><p>——刚学完一些语法写的，验证了几组数据都能达到要求，有漏洞欢迎指正！</p></li></ul><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><p><img src="http://q1oi1oc62.bkt.clouddn.com/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><p>正则表达式对复杂的文本处理具有灵活简洁的优势，正则不仅仅在Java中有，大部分的编程语言、数据库、文本编辑器、开发环境都支持正则表达式，但是在不同环境下可能会有略微不同。在前端正则表达式经常用作校验用户输入的数据是否符合要求。</p><p>正则表达式就是描述了一个规则，通过这个规则可以匹配一类字符串。学习正则表达式很大程度上就是学习它的<strong>语法规则</strong></p><h2 id="开发中使用正则表达式的流程"><a href="#开发中使用正则表达式的流程" class="headerlink" title="开发中使用正则表达式的流程"></a>开发中使用正则表达式的流程</h2><ol><li>分析要匹配的数据，写出对应的正则表达式</li><li>在工具软件中进行匹配测试，设置一些典型数据或者边界值或者是自己不确定是否能匹配到的值；也可以另外写段代码进行测试。</li><li>在程序中调用通过测试的正则表达式。</li></ol><h2 id="语法（1）"><a href="#语法（1）" class="headerlink" title="语法（1）"></a>语法（1）</h2><ul><li><p><strong>普通字符</strong></p><p>字母、数字、汉字、下划线以及没有特殊定义的标点符号都是<strong>“普通字符”</strong>。表达式中的普通字符在匹配一个字符串时，匹配与之相同的一个字符串（比如表达式<code>a2你_!</code>意为匹配<code>a2你_!</code>这个字符串）。</p></li><li><p><strong>简单的转义字符</strong></p><p><img src="http://q1oi1oc62.bkt.clouddn.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%951.png" alt=""></p></li></ul><h2 id="语法（2）"><a href="#语法（2）" class="headerlink" title="语法（2）"></a>语法（2）</h2><ul><li><p><strong>标准字符集合</strong></p><p>——能够与‘多种字符’匹配的表达式</p><p>——<strong>注意区分大小写，大写与小写意思相反，比如\D表示除0~9以外的任何字符</strong></p><table><thead><tr><th align="center">\d</th><th align="center">任意一个0~9的数字</th></tr></thead><tbody><tr><td align="center">\w</td><td align="center">任意一个字母或数字或下划线，即A<del>Z,a</del>z,0~9,_中的任意一个</td></tr><tr><td align="center">\s</td><td align="center">空格、制表符、换行符等空白字符中的任意一个</td></tr><tr><td align="center">.</td><td align="center">小数点匹配除<strong>“\n”</strong>外的所有字符，匹配所有字符一般用<strong>[\s\S]</strong></td></tr></tbody></table><p>[\s\S] 中间相当于有一个或，就是取\s或者\S，\s 取空格、制表符、换行符等空白字符中的任意一个，\S取所有字符去掉\s，所以就取到了所有字符。</p></li></ul><h2 id="语法（3）"><a href="#语法（3）" class="headerlink" title="语法（3）"></a>语法（3）</h2><ul><li><p><strong>自定义字符集合</strong>    </p><p>——[]中括号匹配方式，能够匹配中括号内部的<strong>任意一个</strong>字符</p><table><thead><tr><th align="center">[ab5@]</th><th align="center">匹配“a”或者“b”或者“5”或者“@”</th></tr></thead><tbody><tr><td align="center">[^abc]</td><td align="center">匹配“a”,”b”,”c”<strong>之外</strong>的任意一个字符</td></tr><tr><td align="center">[f-k]</td><td align="center">匹配”f”到”k”之间的任意一个字符（包括f和k）</td></tr><tr><td align="center">[^F-K2-5]</td><td align="center">匹配“F”-“K”,”2”-“5”之外的任意一个字符</td></tr></tbody></table><p>——正则表达式的特殊符号被包括在中括号中则失去特殊意义（比如$在中括号中只表示普通字符”$”），除了    ^,-之外。</p><p>——标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。比如：</p><p>[\d.\-+]将匹配：数字、小数点、+、-</p></li></ul><h2 id="语法（4）"><a href="#语法（4）" class="headerlink" title="语法（4）"></a>语法（4）</h2><ul><li><p><strong>量词</strong></p><p>——修饰匹配字符的次数</p><table><thead><tr><th align="center">{n}</th><th align="center">表达式出现n次</th></tr></thead><tbody><tr><td align="center">{m,n}</td><td align="center">表达式出现最少m次，最多n次</td></tr><tr><td align="center">{m,}</td><td align="center">表达式出现最少m次</td></tr><tr><td align="center">?</td><td align="center">等价于{0,1}，不出现或者出现一次</td></tr><tr><td align="center">+</td><td align="center">表达式至少出现一次，等价于{1,}</td></tr><tr><td align="center">*</td><td align="center">不出现或者任意次，等价于{0,}</td></tr></tbody></table><p>——匹配次数中的<strong>贪婪模式</strong>（匹配字符越多越好，默认！）</p><p>​    比如：表达式：\d{2,3}   样例：12345678  结果：匹配到123, 456, 78</p><p>——<strong>非贪婪模式</strong>（匹配字符越少越好，在表示匹配次数的特殊符号后再加上一个”?”）</p><p>​    比如：表达式：\d{2,3}？   样例：12345678  结果：匹配到12, 34, 56, 78</p><p><strong>注意</strong></p><p>​    \d\d{3}  :  表示匹配4个数字</p><p>​    (\d\d){3}  :  表示匹配6个数字</p></li></ul><h2 id="语法（5）"><a href="#语法（5）" class="headerlink" title="语法（5）"></a>语法（5）</h2><ul><li><p><strong>字符边界</strong></p><p>——（本组标记匹配的不是字符而是位置，符合某种条件的位置）</p><table><thead><tr><th align="center">^</th><th align="center">与字符串开始的地方匹配</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">与字符串结束的地方匹配</td></tr><tr><td align="center">\b</td><td align="center">匹配一个单词边界</td></tr></tbody></table><p>—— \b 匹配这样一个位置：前面的字符和后面的字符不全是\w（字母，数字，下划线）</p><p>​    ysl\b  :  能匹配123ysl,ysl,ysl$不能匹配123ysl123,yslzz,ysl_</p><p>​    ^y  :  <strong>y</strong>sl   rugnjvv y匹配这个字符串开始的位置，如果是sl   rugnjvv y就匹配不到</p><p>​        <strong>注意：^在中括号中是取反的意思</strong></p><p>​    y$  :  ysl   rugnjvv <strong>y</strong>匹配这个字符串开始的位置，如果是ysl   rugnjvv 就匹配不到</p></li></ul><h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><ul><li><p><strong>IGNORECASE忽略大小写模式</strong></p><p>——匹配时忽略大小写。</p><p>——默认情况下，正则表达式是区分大小写的。比如ysl只匹配ysl，不匹配YSL，开启忽略大小写模式后两者都能匹配到。</p></li><li><p><strong>SINGLELINE单行模式</strong></p><p>——整个文本看作一个字符串，只有一个开头和结尾。</p><p><strong>——使小数点“.”可以匹配包含换行符（\n）在内的任意字符。</strong>（注意区别标准字符集合中小数点）</p></li><li><p><strong>MULTILINE多行模式</strong></p><p>——每行都是一个字符串，都有开头和结尾</p><p>——在指定了MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\A和\Z。</p><p>​    \Ay  :  匹配第一行开始位置y，如果第一行开始位置不是y就不匹配</p><p>​    y\Z  :  匹配最后一行结束位置的y，如果最后一行结束位置不是y就不匹配</p></li></ul><h2 id="语法（6）"><a href="#语法（6）" class="headerlink" title="语法（6）"></a>语法（6）</h2><ul><li><p><strong>选择符和分组</strong></p><table><thead><tr><th align="center">表达式</th><th>作用</th></tr></thead><tbody><tr><td align="center">|（分支结构）</td><td>左右两边表达式之间“或”关系，匹配左边或者右边</td></tr><tr><td align="center">()捕获组</td><td>(1)在被修饰匹配次数时，括号中的表达式可以作为整体被修饰<br>(2)取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3)每一对括号会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本</td></tr><tr><td align="center">(?:Expression)非捕获组</td><td>一些表达式中，不得不使用(),但是又不需要保存()中子表达式匹配的内容，这时可以用非捕获组来抵消使用()带来的副作用（在处理大量文本时，保存会消耗大量内存）</td></tr></tbody></table></li><li><p><strong>反向引用（\nnn）</strong></p><p>-每一对()会分配一个编号，使用()的捕获根据<strong>左括号的顺序</strong>从1开始自动编号。</p><p>-通过反向引用，可以对分组<strong>已捕获的字符串</strong>进行引用</p><p>比如([a-z]{2})\1对字符串”abcd  ababb dbdbdb”匹配到”abab”,”dbdb”。意思是a-z任意2个字母作为捕获组，再引用一次</p><p>(?:[a-z]{2})不影响([a-z]{2})表达的意思，只是匹配的内容不会存起来，就无法进行引用，(?:[a-z]{2})\1这个表达式将无效</p></li></ul><h2 id="语法（7）"><a href="#语法（7）" class="headerlink" title="语法（7）"></a>语法（7）</h2><ul><li><p><strong>预搜索（零宽断言）</strong></p><p>——只进行子表达式的匹配，匹配内容不计入最终结果，是零宽度</p><p>——这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但是不匹配前后的字符，是<strong>对位置的匹配</strong>。</p><p>——正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是<strong>占有字符</strong>的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，取决于匹配的内容是否保存到最终匹配结果中。</p><table><thead><tr><th align="center">(?=Expression)</th><th align="center">断言自身出现的位置的<strong>后面能</strong>匹配表达式Expression</th></tr></thead><tbody><tr><td align="center">(?&lt;=Expression)</td><td align="center">断言自身出现的位置的<strong>前面能</strong>匹配表达式Expression</td></tr><tr><td align="center">(?!Expression)</td><td align="center">断言自身出现的位置的<strong>后面不能</strong>匹配表达式Expression</td></tr><tr><td align="center">(?&lt;!Expression)</td><td align="center">断言自身出现的位置的<strong>前面不能</strong>匹配表达式Expression</td></tr></tbody></table><p>[a-z]+(?=ing):对于字符串”acount going running”匹配结果为”go”,”runn”</p></li></ul><h2 id="在Java中使用正则"><a href="#在Java中使用正则" class="headerlink" title="在Java中使用正则"></a>在Java中使用正则</h2><ul><li><p><strong>几个重要类的介绍</strong></p><p>Pattern 类：</p><pre><code>pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</code></pre><p>Matcher 类：</p><pre><code>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</code></pre><p>PatternSyntaxException类：</p><pre><code>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</code></pre></li><li><p><strong>代码示例</strong></p><ol><li>Pattern类的compile方法获取表达式对象，Matcher类的matcher方法将表达式与字符串联系起来，Matcher类的matches方法去匹配整个字符串中是否符合表达式的结果。</li></ol><pre><code class="java">package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Pattern类的compile方法获取表达式对象 * Matcher类的matcher方法将表达式与字符串联系起来 * Matcher类的matches方法去匹配整个字符串中是否符合表达式的结果，类型为boolean * 比如下面“ysl2333”符合“\w+”,但是“ysl$$2333”就不符合了，返回false * @author shulinYuan Email:2762954662@qq.com * */public class Demo1 {    public static void main(String[] args) {        //判断“ysl2333”是否符合正则表达式：\w+        //获取表达式对象        Pattern p = Pattern.compile(&quot;\\w+&quot;);//注意在Java中表示\要用\\        //创建Matcher对象        Matcher m = p.matcher(&quot;ysl2333&quot;);//去匹配整个字符串中是否符合表达式的        boolean flag = m.matches();        System.out.println(flag);//true    }}</code></pre><p>​    2.详解Matcher类的find方法</p><pre><code class="java">package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 详解Matcher类的find方法 * matches方法也会指针停留，如果先调用matches方法匹配到第一个子序列 * 再调用find方法将直接匹配第二个子序列 * @author shulinYuan Email:2762954662@qq.com * */public class Demo2 {    public static void main(String[] args) {        //获取表达式对象        Pattern p = Pattern.compile(&quot;\\w+&quot;);//注意在Java中表示\要用\\        //创建Matcher对象        Matcher m = p.matcher(&quot;ysl2333@@456@@nfj&quot;);        //给出序列是否有子序列符合表达式,调用一次，如果找到一个，那么指针会停留在这，        //下次再调用将匹配下一个子序列        boolean flag = m.find();        System.out.println(flag);//true        flag = m.find();        System.out.println(flag);//true        flag = m.find();        System.out.println(flag);//true        flag = m.find();        System.out.println(flag);//false    }}</code></pre><p>​    3.Matcher类的group方法要与find方法联合使用</p><pre><code class="java">package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Matcher类的group方法要与find方法联合使用，将find方法找到的子序列提取出来 * @author shulinYuan Email:2762954662@qq.com * */public class Demo3 {    public static void main(String[] args) {        //获取表达式对象        Pattern p = Pattern.compile(&quot;\\w+&quot;);//注意在Java中表示\要用\\        //创建Matcher对象        Matcher m = p.matcher(&quot;ysl2333@@456@@nfj&quot;);        /*用法一        m.find();        String str = m.group(0);        System.out.println(str);//ysl2333        m.find();        str = m.group();//等价于group(0)        System.out.println(str);//456        */        while(m.find()) {            System.out.println(m.group());//三个子序列都将被打印：ysl2333，456，nfj            System.out.println(m.group(0));        }    }}</code></pre><p>​    4.测试group方法与捕获组</p><pre><code class="java">package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 测试group方法与捕获组 * @author shulinYuan Email:2762954662@qq.com * */public class Demo4 {    public static void main(String[] args) {        //获取表达式对象        Pattern p = Pattern.compile(&quot;([a-z]+)([0-9]+)&quot;);//注意在Java中表示\要用\\        //创建Matcher对象        Matcher m = p.matcher(&quot;aac223**bbd89**kk99&quot;);        while(m.find()) {            System.out.println(m.group());//aac223,bbd89,kk99            System.out.println(m.group(1));//aac,bbd,kk            System.out.println(m.group(2));//223,89,99        }    }}</code></pre><p>​    5.替换</p><pre><code class="java">package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 替换 * @author shulinYuan Email:2762954662@qq.com * */public class Demo5 {    public static void main(String[] args) {        //获取表达式对象        Pattern p = Pattern.compile(&quot;\\d&quot;);//注意在Java中表示\要用\\        //创建Matcher对象        Matcher m = p.matcher(&quot;aac223**bbd89**kk99&quot;);        //将数字替换成&#39;$&#39;        String newStr = m.replaceAll(&quot;\\$&quot;);        System.out.println(newStr);//aac$$$**bbd$$**kk$$    }}</code></pre><p>​    6.分割</p><pre><code class="java">package regex;/** * 分割 * @author shulinYuan Email:2762954662@qq.com * */public class Demo6 {    public static void main(String[] args) {        String str1 = &quot;a,b,c,d&quot;;        //以逗号切割        String[] newStr1 = str1.split(&quot;,&quot;);        for (String string : newStr1) {            System.out.println(string);        }        String str2 = &quot;abc334gnk667nbjd89&quot;;        //以数字切割        String[] newStr2 = str2.split(&quot;\\d+&quot;);        for (String string : newStr2) {            System.out.println(string);        }    }}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2019/11/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2019/11/28/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="对Java虚拟机的理解"><a href="#对Java虚拟机的理解" class="headerlink" title="对Java虚拟机的理解"></a>对Java虚拟机的理解</h3><p> JVM是Java Virtual Machine（Java虚拟机）的缩写 ，是执行字节码文件（.class）的虚拟机进程。</p><p>java源程序（.java）被编译器编译成字节码文件（.class）,然后Java虚拟机将字节码文件解释成机器码（不同平台的机器码不同），这就是Java虚拟机的基本定义和作用。</p><h3 id="java被称作与平台无关的语言"><a href="#java被称作与平台无关的语言" class="headerlink" title="java被称作与平台无关的语言"></a>java被称作与平台无关的语言</h3><p>Java虚拟机可以将字节码文件编译成该平台对应的机器码，而不需要程序员对运行在不同平台的java程序另外修改代码，也不需要重新编译。真正实现一次编译，到处运行。java虚拟机知道底层硬件平台的指令长度和其他特性</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建自己的hexo博客教程</title>
      <link href="/2019/11/28/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/28/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Git和node-js"><a href="#安装Git和node-js" class="headerlink" title="安装Git和node.js"></a>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>和<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a></h2><p>直接进入官网或者点击我上面的链接，下载对应的Windows系统版本，然后直接安装。检验是否成功：打开cmd，输入<code>node -v</code>,有版本号出来说明node.js安装成功，在桌面鼠标右击，有Git Bash Here选项说明安装成功。</p><h2 id="安装hexo客户端"><a href="#安装hexo客户端" class="headerlink" title="安装hexo客户端"></a>安装hexo客户端</h2><p>在你电脑D盘或别的盘，新建个目录如hexo，回到桌面，右击打开Git Bash Here,这是一个类似Linux终端的界面，保证在你新建的目录下执行<code>npm install -g hexo-cli</code>命令，安装hexo客户端，然后执行<code>hexo init blog</code>,blog是自定义的，会生成这个目录，操作过程如下</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128104501240.png" alt=""></p><h2 id="安装npm（-Node-Package-包-Manager-管理器-）"><a href="#安装npm（-Node-Package-包-Manager-管理器-）" class="headerlink" title="安装npm（ Node Package(包) Manager(管理器)）"></a>安装npm（ Node Package(包) Manager(管理器)）</h2><p>先进入刚刚生成的目录blog，再执行<code>npm install</code>，如果输出信息有提示你 <strong>use npm audit fix –force to install breaking changes; or refer to npm audit for steps to fix these manually)</strong> 那么你再执行一下<code>npm audit fix</code> 检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖 ,如果没有提示则不必执行。（你要是不清楚是否需要执行就执行一下，反正这条命令也是检测环境的命令）像我下面就没有出现提示</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128105618030.png" alt=""></p><h2 id="完成搭建"><a href="#完成搭建" class="headerlink" title="完成搭建"></a>完成搭建</h2><p>执行<code>hexo generate</code>或者缩写<code>hexo g</code>,生成静态博客</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128105917349.png" alt=""></p><p>执行<code>hexo serve</code>或者缩写<code>hexo s</code>,启动服务</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128110056206.png" alt=""></p><p>正常启动后，打开浏览器，地址栏访问localhost:4000,就可以看到hexo的默认页面</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128110333384.png" alt=""></p><p>在git bash下Ctrl+C关闭hexo server</p><h2 id="托管到github仓库"><a href="#托管到github仓库" class="headerlink" title="托管到github仓库"></a>托管到github仓库</h2><p>你要有一个github的账号，然后新建一个空的存储库，<strong>注意：你存储库的名字必须是</strong><code>xxxxx.github.io</code>,xxxxx就是你的github用户名，然后回到git bash安装deployer-git,这是用来将你的博客推送到github仓库的工具，执行<code>npm install hexo-deployer-git</code>，这是在blog下执行，不是在hexo</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128111747192.png" alt=""></p><p>然后去本地修改_config.yml文件，</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128112005016.png" alt=""></p><p>找到deploy配置如下：</p><pre><code>deploy:  type: git  repo: https://github.com/yslinzz/abc.github.io.git  branch: master</code></pre><p><strong>注意：每一个冒号后面要有一个空格，repo是刚刚你自己建的那个空的仓库的地址，如下图（我这里abc命名是随便写的，与前面冲突，不要在意）</strong></p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128112647499.png" alt=""></p><p>然后执行<code>hexo clean</code>清理一下，再执行<code>hexo generate</code>或者<code>hexo g</code> 生成静态博客系统 ,最后执行<code>hexo deploy</code>或者缩写<code>hexo d</code>将博客系统推送到GitHub并发布</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128113444910.png" alt=""></p><p>成功后，你在GitHub仓库刷新就会有你的博客系统，此时你在地址栏访问刚刚在_config.yml中配置的repo就可以访问到你的博客了</p><p><img src="http://q1oi1oc62.bkt.clouddn.com/image-20191128113800406.png" alt=""></p><p>至此，你的个人博客就搭建并发布完成，后续你可以找一个漂亮的主题，然后在上面记录你的点点滴滴，有问题可以在<a href="https://yuanshulin.com/">我的博客</a>下留言，或者Email我，</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
