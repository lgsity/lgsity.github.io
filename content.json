{"meta":{"title":"小白","subtitle":null,"description":"fell","author":"小白","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-12-06T06:31:04.156Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-12-05T15:56:01.693Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-12-06T06:58:28.702Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"","keywords":"关于"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-16T09:29:49.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-16T09:29:49.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"technology","slug":"technology","date":"2019-12-06T09:14:13.000Z","updated":"2019-12-06T09:16:15.229Z","comments":true,"path":"2019/12/06/technology/","link":"","permalink":"/2019/12/06/technology/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"转载","slug":"转载","date":"2019-12-06T08:01:35.000Z","updated":"2019-12-06T08:03:31.201Z","comments":true,"path":"2019/12/06/转载/","link":"","permalink":"/2019/12/06/转载/","excerpt":"","text":"","categories":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}],"tags":[],"keywords":[{"name":"转载","slug":"转载","permalink":"/categories/转载/"}]},{"title":"随想","slug":"随想","date":"2019-12-06T08:01:24.000Z","updated":"2019-12-06T08:02:56.071Z","comments":true,"path":"2019/12/06/随想/","link":"","permalink":"/2019/12/06/随想/","excerpt":"","text":"","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"资源","slug":"资源","date":"2019-12-06T07:54:44.000Z","updated":"2019-12-06T07:56:25.244Z","comments":true,"path":"2019/12/06/资源/","link":"","permalink":"/2019/12/06/资源/","excerpt":"","text":"","categories":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}],"tags":[],"keywords":[{"name":"资源","slug":"资源","permalink":"/categories/资源/"}]},{"title":"生活","slug":"生活","date":"2019-12-06T07:52:34.000Z","updated":"2019-12-06T07:56:45.764Z","comments":true,"path":"2019/12/06/生活/","link":"","permalink":"/2019/12/06/生活/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"Java基础（二）","slug":"Java基础（二）","date":"2019-12-01T11:02:28.000Z","updated":"2019-12-05T09:22:13.914Z","comments":true,"path":"2019/12/01/Java基础（二）/","link":"","permalink":"/2019/12/01/Java基础（二）/","excerpt":"","text":"大O符号(big-O notation) 大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。 同时，大O符号表示一个程序运行时所需要的渐进时间复杂度上界。 其函数表示是： 对于函数f(n),g(n),如果存在一个常数c，使得f(n)&lt;=c*g(n),则f(n)=O(g(n)); 大O描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。 大O还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大O符号基于时间，内存，性能选择最好的实现。大O符号可以对大量数据性能给予一个很好的说明。 数组(Array)和列表(ArrayList)的区别及使用场景 区别：Array可以包含基本数据类型和对象类型，ArrayList只能包含对象类型；Array大小固定，ArrayList大小动态变化；ArrayList提供更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 场景：处理固定大小时用Array（限于多为查找操作），动态用ArrayList（限于多为查找操作），多为增删改操作用LinkedList（底层是链表）。 java.util.ArrayList &lt; E &gt; 的一些方法 描述 ArrayList() 构造函数，创建一个空的列表, size为0 add(y:E): void 在list的末尾添加一个元素y add(index:int,y:E):void 在指定的index处插入元素y clear(): void 从list中删除所有元素 contains(y: Object): boolean 如果list含有元素y，返回true get(index: int): E 返回指定index处的元素 indexOf(y: Object): int 返回list中第一个匹配元素的index isEmpty(): boolean 如果list不含元素，返回true lastIndexOf(y: Object): int 返回list中最后一个匹配元素的index remove(y: Object): boolean 删除list中的第一个元素y，如果元素被删除，返回true size(): int 返回list中元素个数 remove(index: int): boolean 删除指定index处的元素，如果元素被删除，返回true set(index: int, y: E): E 设置指定index处的元素为y 数组和ArrayList的比较 操作 Array ArrayList 创建 array/ArrayList String[] a = new String[10] ArrayList list = new ArrayList&lt;&gt;(); 访问一个元素 a[index] list.get(index); 更新一个元素 a[index] = “London”; list.set(index, “London”); 返回大小 a.length list.size(); 排序 java.util.Arrays.sort(array) java.util.Collections.sort(arraylist) 添加一个新元素 很麻烦 list.add(“London”); 插入一个新元素 很麻烦 list.add(index, “London”); 删除一个元素 很麻烦 list.remove(index); 删除一个元素 很麻烦 list.remove(Object); 删除所有元素 没有 list.clear(); 值传递和引用传递 看了一篇博客真的讲的很精彩，这里推荐给大家：这一次，让你彻底明白Java的值传递和引用传递！ 我自己再总结一下，Java中值传递是针对基本变量而言的，传递的是值的拷贝，引用传递其实是把实参地址的拷贝传递给了形参，导致形参变量也指向实参变量地址，传递的并不是对象本身，所以一般对引用对象操作会改变对象本身，一般认为,java内的传递都是值传递. 12345678910111213141516171819202122232425262728293031323334353637package basis;/** * 值传递，引用传递 * @author shulinYuan Email:2762954662@qq.com * */public class Demo06 &#123; public static void main(String[] args) &#123; int a = 5; //值传递 change1(a); System.out.println(a);//a=5 //引用传递 StringBuffer str = new StringBuffer(\"Hello\"); change2(str); System.out.println(str);//Hello World! //引用传递，但是并没有改变str值，如果改变应该为//Hello World! World! change3(str); System.out.println(str);//Hello World! &#125; public static void change1(int x) &#123; x = x +1; &#125; public static void change2(StringBuffer stBf) &#123; stBf.append(\" World!\"); &#125; public static void change3(StringBuffer stBf) &#123; stBf = new StringBuffer(); stBf.append(\" World!\"); &#125;&#125; 为什么会出现4.0-3.6=0.40000001这种现象？ 原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。 把3.6转成2进制你会发现是无限循环小数（转一下你就明白了） 十进制小数转二进制方法 0.8125的二进制 0.8125*2=1.625 取整是1 0.625*2=1.25 取整是1 0.25*2=0.5 取整是0 0.5*2=1.0 取整是1 即0.8125的二进制是0.1101（第一次所得到为最高位,最后一次得到为最低位） 十进制的数在内存中的存储 以补码形式存储 原因： 补码可以表示-128~127的255个有符号数，而原码和反码只能表示-127~127的254个有符号数，因为0会出现重码（-0和0） 补码还有很多特性，这些特性为符号数的运算提供了方便。(而且有些特性“原码”和“反码”是不具备的) 补码定义:正数的补码与原码相同；负数的补码是对其原码逐位取反，但符号位除外；然后整个数加1。 [X]补:表示X的补码 |X|:表示X的绝对值 当X &lt; 0 时[X]补 = 2~8 - |X|； 当X &gt;=0 时[X]补 = |X| =X； 1） [X+Y]补 = [X]补 +[Y]补 2） [X-Y]补 = [X]补 - [Y]补 = [X]补 + [-Y]补 3） [X*Y]补=[X]补*[Y]补 (乘数（被乘数）相乘的补码等于补码的相乘。) 4） 正数的补码取反加1后，为其对应的负数的补码；负数的补码取反加1后为其绝对值的补码。即:X&gt;=0:[ [-X]补 ]补 = |X| = XX&lt;0 [ [X]补]补 = |X| = -X等等…… 符号“==”比较的是什么？ 对于基本数据类型，“==”比较的是数值，只要两个变量的值相等，就返回true；对于引用类型（对象类型）比较的是两个变量是否指向同一个对象，如果是返回true equals()方法是Object类提供的一个实例方法，只有引用变量才有，判断两个对象是否相等的标准和“==”一样；但是在String类中以经重写该方法，所以只要两个字符串包含的字符序列相同，equals（）就返回true 123456789101112131415161718192021package basis;/** * \"==\",equals() * @author shulinYuan * @Email:2762954662@qq.com */public class Demo07 &#123; public static void main(String[] args) &#123; int a = 97; char b = 'a'; float c = 97.0f; String str1 = new String(\"Hello\"); String str2 = new String(\"Hello\"); System.out.println(a==b);//true System.out.println(a==c);//true System.out.println(c==b);//true System.out.println(str1==str2);//false System.out.println(str1.equals(str2));//true &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"Java基础（一）","slug":"Java基础（一）","date":"2019-12-01T02:35:00.000Z","updated":"2019-12-05T09:20:36.459Z","comments":true,"path":"2019/12/01/Java基础（一）/","link":"","permalink":"/2019/12/01/Java基础（一）/","excerpt":"","text":"Java中如何跳出当前的多重嵌套循环 可以用带标签的break语句跳出，但是在Java中应该避免使用带标签break和continue语句，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好 123456789101112131415161718192021222324252627282930313233343536373839package basis;/** * 跳出多重嵌套循环 * @author shulinYuan Email:2762954662@qq.com * */public class Demo01 &#123; public static void main(String[] args) &#123; method1(); method2(); &#125; //定义标号，break退出 public static void method1() &#123; out://外层循环定义标号 for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;10;j++) &#123; System.out.println(\"i=\"+i+\",j=\"+j); if(j==6) break out;//使用标号 &#125; &#125; &#125; //让外层循环受到内层循环的控制 public static void method2() &#123; boolean flag = false; for(int i=0;i&lt;10&amp;&amp;!flag;i++) &#123; for(int j=0;j&lt;10;j++) &#123; System.out.println(\"i=\"+i+\",j=\"+j); if(j==6) &#123; flag = true;//内层控制外层 break;//跳出内层循环 &#125; &#125; &#125; &#125;&#125; break和continue的区别(觉得这个很形象，就摘抄过来了) 假设有10个人参加面试，现在进行到第三个人了，突然，面试官有事了，需要走，那么今天剩下这些人就没有办法继续面试了，显然面试整个结束了。(break) 假设有10个人参加面试，现在进行到第三个人了，面试官想要招聘一位女生做秘书，但是这第三个人是一位男士，面试官说：今天咱们就聊到这里吧，下一位。（continue） &amp;和&amp;&amp;的区别 &amp;有按位与和逻辑与，按位与就是把两个数都转化成二进制，然后逐位相与，比如下面的5&amp;6，就是00000101和00000110相与，结果为00000100，即4；逻辑与&amp;是非短路与，就是所有条件都会判断，短路与&amp;&amp;就是判断到当前条件不符合就不会再判断剩下的条件，测试代码如下： 123456789101112131415161718192021222324252627282930package basis;/** * &amp;与&amp;&amp;的区别 * @author shulinYuan Email:2762954662@qq.com * */public class Demo02 &#123; public static void main(String[] args) &#123; //按位与&amp; int x = 5 &amp; 6; System.out.println(x);//x=4 int a = 1; int b = 2; try &#123; //非短路与&amp; if(a&gt;b &amp; a&lt;b/0) System.out.println(\"不可能输出\"); &#125;catch (ArithmeticException e) &#123; System.out.println(\"非短路与&amp;就是所有条件都会判断，所以这里会报错，然后输出我。\"); &#125; //短路与&amp;&amp; if(a&gt;b &amp;&amp; a&lt;b/0) &#123; System.out.println(\"不可能输出\"); &#125;else &#123; System.out.println(\"短路与&amp;&amp;就是当条件不满足时，后面的条件不会再判断，所以这里不会报错\"); &#125; &#125;&#125; int和Integer的区别 最主要的区别就是int是基本数据类型，Integer是int的包装类，用面向对象的思想去看Integer，Java是一个近乎纯洁的面向对象编程语言，但是为了编程方便还是引入了基本数据类型，但是为了能把这些数据类型当作对象操作，Java为每一个基本数据类型都引入了对应的包装类型，从Java5开始引入了自动装/拆箱机制，使得二者可以相互转换。 装箱就是把int转成Integer对象，拆箱与之相反；对象缺省值是null，基本数据类型缺省值和类型有关，Integer缺省值是null，int缺省值是0。 12345678910111213141516package basis;/** * 自动装箱，拆箱 * @author shulinYuan Email:2762954662@qq.com * */public class Demo03 &#123; public static void main(String[] args) &#123; Integer a = 5;//自动装箱 Integer b = new Integer(5); int c = 5; System.out.println(a==b);//false,a,b为两个不同的对象 System.out.println(a==c);//true,a自动拆箱成int类型与c比较 &#125;&#125; ——原始类型：byte, int, long, float, double, short, char, boolean ——包装类型：Byte, Integer, Long, Float, Double, Short, Character, Boolean 如何输出一个某种编码的字符串 字符串先调用getBytes(String charsetName)（参数为当前字符串的编码格式）转换成字节数组，再将此字节数组和要转换成的字节编码一起作为参数传入String类的构造方法中，即可生成指定编码的字符串，测试代码如下： 123456789101112131415161718192021package basis;/** * 输出指定编码字符串 * @author shulinYuan Email:2762954662@qq.com * */public class Demo04 &#123; public static void main(String[] args) &#123; String str = \"abcd\"; String tempStr = \"\"; try &#123; tempStr = new String(str.getBytes(\"utf-8\"), \"unicode\"); tempStr = tempStr.trim();//trim() 方法用于删除字符串的头尾空白符。 &#125; catch (Exception e) &#123; System.err.println(e.getMessage()); &#125; System.out.println(tempStr);//慢捤 &#125;&#125; String 和StringBuffer的区别 String类是final的，不可修改的，只要改动了那就一定不是原来的对象，StringBuffer类拥有很多修改的方法，最重要的是不需要创建新的对象。String使用+拼接字符串时，一定要找一个新的更大的内存来存储，这是非常耗时的，而StringBuffer是预先就分配了指定长度的内存空间，不需要频繁分配内存，所以操作经常需要修改的字符串还是使用StringBuffer效率更高。 1234567891011121314151617181920212223242526272829303132333435package basis;/** * String和StringBuffer区别 * @author shulinYuan Email:2762954662@qq.com * */public class Demo05 &#123; public static void main(String[] args) &#123; StringBuffer sb1 = new StringBuffer();//分配16字节字符缓冲区 StringBuffer sb2 = new StringBuffer(1024);//分配1024字节字符缓冲区 StringBuffer sb = new StringBuffer(\"I'm better!\"); //追加方法 sb.append(\"yes\"); System.out.println(sb);//I'm better!yes //指定位置删除,从0开始 sb.deleteCharAt(1); System.out.println(sb);//Im better!yes //删除一定范围位置的字符，包括开始位置，不包括结束位置 sb.delete(0, 7); System.out.println(sb);//er!yes //在指定位置插入字符串 sb.insert(6, \"hello\"); System.out.println(sb);//er!yeshello //反向方法：将字符串内容反转，形成新的字符串 sb.reverse(); System.out.println(sb);//ollehsey!re //替换指定位置字符 sb.setCharAt(6, 'A'); System.out.println(sb);//ollehsAy!re //替换指定位置字符串 sb.replace(0, 3, \"Hello\"); System.out.println(sb);//HelloehsAy!re &#125;&#125; String不是最基本的数据类型 Java中只有8大基本数据类型(primitive type)，除此之外都是引用类型(reference type),枚举类型（enumeration type）也是引用类型。 java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。 byte(1个字节),int(4个字节),long(8个字节),float(4个字节),doublelong(8个字节),char(2个字节),boolean(理论上占用1bit,1/8字节，实际处理按1byte处理) ,short(2个字节)","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"/tags/Java基础/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"正则表达式练习","slug":"正则表达式练习","date":"2019-11-30T08:36:41.000Z","updated":"2019-12-05T09:24:41.471Z","comments":true,"path":"2019/11/30/正则表达式练习/","link":"","permalink":"/2019/11/30/正则表达式练习/","excerpt":"","text":"电话号码验证 要求 固定电话：如果有区号，那么区号可以是3位或者4位，首位必须是0，电话号码为7位到8位，区号与电话号码之间用“-”连接，如果没有区号，电话号码为7位到8位。 移动电话：11位，第一第二位为“13”，“15”，“18”三者之一。 我的思路 先求不含区号的固定电话正则表达式：\\d{7,8} 再求含区号的：0\\d{2,3}-\\d{7,8} 移动的：1[358]\\d{9} 最后把他们用或连接：(\\d{7,8})|(0\\d{2,3}-\\d{7,8})|(1[358]\\d{9}) 过程中我以为表示或需要转义，使用的是\\|,导致验证出错，这里再次提醒自己，|表示“或”的意思，\\|单纯得表示“|”字符，没有特殊含义。 验证 12345678910111213141516171819package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Telephone &#123; public static void main(String[] args)&#123; //需要验证的手机号 String tel=\"12631721765\"; //正则表达式 String reg =\"(0\\\\d&#123;2,3&#125;-\\\\d&#123;7,8&#125;)|(\\\\d&#123;7,8&#125;)|(1[358]\\\\d&#123;9&#125;)\" ; //编译正则表达式 Pattern pattern = Pattern.compile(reg); Matcher matcher = pattern.matcher(tel); // 字符串是否与正则表达式相匹配 boolean rs = matcher.matches(); System.out.println(rs); &#125; &#125; 邮箱验证 要求 用户名：字母、数字、中划线、下划线组成 @ 网址：字母、数字组成 小数点：. 组织域名：2-4位字母组成 我的思路 这个邮箱的话直接匹配，就是一条条规则去满足，用户名：[\\w-]+,到@：[\\w-]+@,到网址：[\\w-]+@[A-Za-z0-9]+，到小数点，这里小数点和组织域名应该看成一个组合，因为有的会有.org.cn这样两组的，所以到小数点和组织域名：[\\w-]+@[A-Za-z0-9]+(\\.[A-Za-z]{2,4}){1,2} 验证 可以采用专门的正则表达式的软件工具验证，也可以用我上面那段代码验证 ——刚学完一些语法写的，验证了几组数据都能达到要求，有漏洞欢迎指正！ 常用正则表达式","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"/tags/正则表达式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-11-29T12:34:17.000Z","updated":"2019-12-05T09:24:06.123Z","comments":true,"path":"2019/11/29/正则表达式/","link":"","permalink":"/2019/11/29/正则表达式/","excerpt":"","text":"正则表达式简介正则表达式对复杂的文本处理具有灵活简洁的优势，正则不仅仅在Java中有，大部分的编程语言、数据库、文本编辑器、开发环境都支持正则表达式，但是在不同环境下可能会有略微不同。在前端正则表达式经常用作校验用户输入的数据是否符合要求。 正则表达式就是描述了一个规则，通过这个规则可以匹配一类字符串。学习正则表达式很大程度上就是学习它的语法规则 开发中使用正则表达式的流程 分析要匹配的数据，写出对应的正则表达式 在工具软件中进行匹配测试，设置一些典型数据或者边界值或者是自己不确定是否能匹配到的值；也可以另外写段代码进行测试。 在程序中调用通过测试的正则表达式。 语法（1） 普通字符 字母、数字、汉字、下划线以及没有特殊定义的标点符号都是“普通字符”。表达式中的普通字符在匹配一个字符串时，匹配与之相同的一个字符串（比如表达式a2你_!意为匹配a2你_!这个字符串）。 简单的转义字符 语法（2） 标准字符集合 ——能够与‘多种字符’匹配的表达式 ——注意区分大小写，大写与小写意思相反，比如\\D表示除0~9以外的任何字符 | \\d | 任意一个0~9的数字 || :–: | :———————————————————-: || \\w | 任意一个字母或数字或下划线，即A~Z,a~z,0~9,_中的任意一个 || \\s | 空格、制表符、换行符等空白字符中的任意一个 || . | 小数点匹配除“\\n”外的所有字符，匹配所有字符一般用[\\s\\S] | [\\s\\S] 中间相当于有一个或，就是取\\s或者\\S，\\s 取空格、制表符、换行符等空白字符中的任意一个，\\S取所有字符去掉\\s，所以就取到了所有字符。 语法（3） 自定义字符集合 ——[]中括号匹配方式，能够匹配中括号内部的任意一个字符 | [ab5@] | 匹配“a”或者“b”或者“5”或者“@” || :——-: | :—————————————-: || [^abc] | 匹配“a”,”b”,”c”之外的任意一个字符 || [f-k] | 匹配”f”到”k”之间的任意一个字符（包括f和k） || [^F-K2-5] | 匹配“F”-“K”,”2”-“5”之外的任意一个字符 | ——正则表达式的特殊符号被包括在中括号中则失去特殊意义（比如$在中括号中只表示普通字符”$”），除了 ^,-之外。 ——标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。比如： [\\d.\\-+]将匹配：数字、小数点、+、- 语法（4） 量词 ——修饰匹配字符的次数 | {n} | 表达式出现n次 || :—: | :—————————–: || {m,n} | 表达式出现最少m次，最多n次 || {m,} | 表达式出现最少m次 || ? | 等价于{0,1}，不出现或者出现一次 || + | 表达式至少出现一次，等价于{1,} || * | 不出现或者任意次，等价于{0,} | ——匹配次数中的贪婪模式（匹配字符越多越好，默认！） ​ 比如：表达式：\\d{2,3} 样例：12345678 结果：匹配到123, 456, 78 ——非贪婪模式（匹配字符越少越好，在表示匹配次数的特殊符号后再加上一个”?”） ​ 比如：表达式：\\d{2,3}？ 样例：12345678 结果：匹配到12, 34, 56, 78 注意 ​ \\d\\d{3} : 表示匹配4个数字 ​ (\\d\\d){3} : 表示匹配6个数字 语法（5） 字符边界 ——（本组标记匹配的不是字符而是位置，符合某种条件的位置） | ^ | 与字符串开始的地方匹配 || :–: | :——————–: || $ | 与字符串结束的地方匹配 || \\b | 匹配一个单词边界 | —— \\b 匹配这样一个位置：前面的字符和后面的字符不全是\\w（字母，数字，下划线） ​ ysl\\b : 能匹配123ysl,ysl,ysl$不能匹配123ysl123,yslzz,ysl_ ​ ^y : ysl rugnjvv y匹配这个字符串开始的位置，如果是sl rugnjvv y就匹配不到 ​ 注意：^在中括号中是取反的意思 ​ y$ : ysl rugnjvv y匹配这个字符串开始的位置，如果是ysl rugnjvv 就匹配不到 匹配模式 IGNORECASE忽略大小写模式 ——匹配时忽略大小写。 ——默认情况下，正则表达式是区分大小写的。比如ysl只匹配ysl，不匹配YSL，开启忽略大小写模式后两者都能匹配到。 SINGLELINE单行模式 ——整个文本看作一个字符串，只有一个开头和结尾。 ——使小数点“.”可以匹配包含换行符（\\n）在内的任意字符。（注意区别标准字符集合中小数点） MULTILINE多行模式 ——每行都是一个字符串，都有开头和结尾 ——在指定了MULTILINE之后，如果需要仅匹配字符串开始和结束位置，可以使用\\A和\\Z。 ​ \\Ay : 匹配第一行开始位置y，如果第一行开始位置不是y就不匹配 ​ y\\Z : 匹配最后一行结束位置的y，如果最后一行结束位置不是y就不匹配 语法（6） 选择符和分组 | 表达式 | 作用 || :——————–: | ———————————————————— || |（分支结构） | 左右两边表达式之间“或”关系，匹配左边或者右边 || ()捕获组 | (1)在被修饰匹配次数时，括号中的表达式可以作为整体被修饰(2)取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到(3)每一对括号会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号。捕获元素编号为0的第一个捕获是由整个正则表达式模式匹配的文本 || (?:Expression)非捕获组 | 一些表达式中，不得不使用(),但是又不需要保存()中子表达式匹配的内容，这时可以用非捕获组来抵消使用()带来的副作用（在处理大量文本时，保存会消耗大量内存） | 反向引用（\\nnn） -每一对()会分配一个编号，使用()的捕获根据左括号的顺序从1开始自动编号。 -通过反向引用，可以对分组已捕获的字符串进行引用 比如([a-z]{2})\\1对字符串”abcd ababb dbdbdb”匹配到”abab”,”dbdb”。意思是a-z任意2个字母作为捕获组，再引用一次 (?:[a-z]{2})不影响([a-z]{2})表达的意思，只是匹配的内容不会存起来，就无法进行引用，(?:[a-z]{2})\\1这个表达式将无效 语法（7） 预搜索（零宽断言） ——只进行子表达式的匹配，匹配内容不计入最终结果，是零宽度 ——这个位置应该符合某个条件。判断当前位置的前后字符，是否符合指定的条件，但是不匹配前后的字符，是对位置的匹配。 ——正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。占有字符还是零宽度，取决于匹配的内容是否保存到最终匹配结果中。 | (?=Expression) | 断言自身出现的位置的后面能匹配表达式Expression || :————-: | :————————————————–: || (?&lt;=Expression) | 断言自身出现的位置的前面能匹配表达式Expression || (?!Expression) | 断言自身出现的位置的后面不能匹配表达式Expression || (?&lt;!Expression) | 断言自身出现的位置的前面不能匹配表达式Expression | [a-z]+(?=ing):对于字符串”acount going running”匹配结果为”go”,”runn” 在Java中使用正则 几个重要类的介绍 Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException类： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 代码示例 Pattern类的compile方法获取表达式对象，Matcher类的matcher方法将表达式与字符串联系起来，Matcher类的matches方法去匹配整个字符串中是否符合表达式的结果。 123456789101112131415161718192021222324package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Pattern类的compile方法获取表达式对象 * Matcher类的matcher方法将表达式与字符串联系起来 * Matcher类的matches方法去匹配整个字符串中是否符合表达式的结果，类型为boolean * 比如下面“ysl2333”符合“\\w+”,但是“ysl$$2333”就不符合了，返回false * @author shulinYuan Email:2762954662@qq.com * */public class Demo1 &#123; public static void main(String[] args) &#123; //判断“ysl2333”是否符合正则表达式：\\w+ //获取表达式对象 Pattern p = Pattern.compile(\"\\\\w+\");//注意在Java中表示\\要用\\\\ //创建Matcher对象 Matcher m = p.matcher(\"ysl2333\");//去匹配整个字符串中是否符合表达式的 boolean flag = m.matches(); System.out.println(flag);//true &#125;&#125; ​ 2.详解Matcher类的find方法 123456789101112131415161718192021222324252627282930package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 详解Matcher类的find方法 * matches方法也会指针停留，如果先调用matches方法匹配到第一个子序列 * 再调用find方法将直接匹配第二个子序列 * @author shulinYuan Email:2762954662@qq.com * */public class Demo2 &#123; public static void main(String[] args) &#123; //获取表达式对象 Pattern p = Pattern.compile(\"\\\\w+\");//注意在Java中表示\\要用\\\\ //创建Matcher对象 Matcher m = p.matcher(\"ysl2333@@456@@nfj\"); //给出序列是否有子序列符合表达式,调用一次，如果找到一个，那么指针会停留在这， //下次再调用将匹配下一个子序列 boolean flag = m.find(); System.out.println(flag);//true flag = m.find(); System.out.println(flag);//true flag = m.find(); System.out.println(flag);//true flag = m.find(); System.out.println(flag);//false &#125;&#125; ​ 3.Matcher类的group方法要与find方法联合使用 12345678910111213141516171819202122232425262728293031package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Matcher类的group方法要与find方法联合使用，将find方法找到的子序列提取出来 * @author shulinYuan Email:2762954662@qq.com * */public class Demo3 &#123; public static void main(String[] args) &#123; //获取表达式对象 Pattern p = Pattern.compile(\"\\\\w+\");//注意在Java中表示\\要用\\\\ //创建Matcher对象 Matcher m = p.matcher(\"ysl2333@@456@@nfj\"); /*用法一 m.find(); String str = m.group(0); System.out.println(str);//ysl2333 m.find(); str = m.group();//等价于group(0) System.out.println(str);//456 */ while(m.find()) &#123; System.out.println(m.group());//三个子序列都将被打印：ysl2333，456，nfj System.out.println(m.group(0)); &#125; &#125;&#125; ​ 4.测试group方法与捕获组 123456789101112131415161718192021222324package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 测试group方法与捕获组 * @author shulinYuan Email:2762954662@qq.com * */public class Demo4 &#123; public static void main(String[] args) &#123; //获取表达式对象 Pattern p = Pattern.compile(\"([a-z]+)([0-9]+)\");//注意在Java中表示\\要用\\\\ //创建Matcher对象 Matcher m = p.matcher(\"aac223**bbd89**kk99\"); while(m.find()) &#123; System.out.println(m.group());//aac223,bbd89,kk99 System.out.println(m.group(1));//aac,bbd,kk System.out.println(m.group(2));//223,89,99 &#125; &#125;&#125; ​ 5.替换 123456789101112131415161718192021package regex;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 替换 * @author shulinYuan Email:2762954662@qq.com * */public class Demo5 &#123; public static void main(String[] args) &#123; //获取表达式对象 Pattern p = Pattern.compile(\"\\\\d\");//注意在Java中表示\\要用\\\\ //创建Matcher对象 Matcher m = p.matcher(\"aac223**bbd89**kk99\"); //将数字替换成'$' String newStr = m.replaceAll(\"\\\\$\"); System.out.println(newStr);//aac$$$**bbd$$**kk$$ &#125;&#125; ​ 6.分割 1234567891011121314151617181920212223package regex;/** * 分割 * @author shulinYuan Email:2762954662@qq.com * */public class Demo6 &#123; public static void main(String[] args) &#123; String str1 = \"a,b,c,d\"; //以逗号切割 String[] newStr1 = str1.split(\",\"); for (String string : newStr1) &#123; System.out.println(string); &#125; String str2 = \"abc334gnk667nbjd89\"; //以数字切割 String[] newStr2 = str2.split(\"\\\\d+\"); for (String string : newStr2) &#123; System.out.println(string); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"/tags/正则表达式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"Java虚拟机","slug":"Java虚拟机","date":"2019-11-28T15:23:04.000Z","updated":"2019-12-05T09:23:11.100Z","comments":true,"path":"2019/11/28/Java虚拟机/","link":"","permalink":"/2019/11/28/Java虚拟机/","excerpt":"","text":"对Java虚拟机的理解 JVM是Java Virtual Machine（Java虚拟机）的缩写 ，是执行字节码文件（.class）的虚拟机进程。 java源程序（.java）被编译器编译成字节码文件（.class）,然后Java虚拟机将字节码文件解释成机器码（不同平台的机器码不同），这就是Java虚拟机的基本定义和作用。 java被称作与平台无关的语言Java虚拟机可以将字节码文件编译成该平台对应的机器码，而不需要程序员对运行在不同平台的java程序另外修改代码，也不需要重新编译。真正实现一次编译，到处运行。java虚拟机知道底层硬件平台的指令长度和其他特性","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"java虚拟机","slug":"java虚拟机","permalink":"/tags/java虚拟机/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"搭建自己的hexo博客教程","slug":"搭建自己的hexo博客教程","date":"2019-11-28T14:10:26.000Z","updated":"2019-12-06T09:12:10.393Z","comments":true,"path":"2019/11/28/搭建自己的hexo博客教程/","link":"","permalink":"/2019/11/28/搭建自己的hexo博客教程/","excerpt":"","text":"安装Git和node.js直接进入官网或者点击我上面的链接，下载对应的Windows系统版本，然后直接安装。检验是否成功：打开cmd，输入node -v,有版本号出来说明node.js安装成功，在桌面鼠标右击，有Git Bash Here选项说明安装成功。 安装hexo客户端在你电脑D盘或别的盘，新建个目录如hexo，回到桌面，右击打开Git Bash Here,这是一个类似Linux终端的界面，保证在你新建的目录下执行npm install -g hexo-cli命令，安装hexo客户端，然后执行hexo init blog,blog是自定义的，会生成这个目录，操作过程如下 安装npm（ Node Package(包) Manager(管理器)）先进入刚刚生成的目录blog，再执行npm install，如果输出信息有提示你 use npm audit fix –force to install breaking changes; or refer to npm audit for steps to fix these manually) 那么你再执行一下npm audit fix 检测项目依赖中的漏洞并自动安装需要更新的有漏洞的依赖 ,如果没有提示则不必执行。（你要是不清楚是否需要执行就执行一下，反正这条命令也是检测环境的命令）像我下面就没有出现提示 完成搭建执行hexo generate或者缩写hexo g,生成静态博客 执行hexo serve或者缩写hexo s,启动服务 正常启动后，打开浏览器，地址栏访问localhost:4000,就可以看到hexo的默认页面 在git bash下Ctrl+C关闭hexo server 托管到github仓库你要有一个github的账号，然后新建一个空的存储库，注意：你存储库的名字必须是xxxxx.github.io,xxxxx就是你的github用户名，然后回到git bash安装deployer-git,这是用来将你的博客推送到github仓库的工具，执行npm install hexo-deployer-git，这是在blog下执行，不是在hexo 然后去本地修改_config.yml文件， 找到deploy配置如下： 1234deploy: type: git repo: https://github.com/yslinzz/abc.github.io.git branch: master 注意：每一个冒号后面要有一个空格，repo是刚刚你自己建的那个空的仓库的地址，如下图（我这里abc命名是随便写的，与前面冲突，不要在意） 然后执行hexo clean清理一下，再执行hexo generate或者hexo g 生成静态博客系统 ,最后执行hexo deploy或者缩写hexo d将博客系统推送到GitHub并发布 成功后，你在GitHub仓库刷新就会有你的博客系统，此时你在地址栏访问刚刚在_config.yml中配置的repo就可以访问到你的博客了 至此，你的个人博客就搭建并发布完成，后续你可以找一个漂亮的主题，然后在上面记录你的点点滴滴，有问题可以在我的博客下留言，或者Email我，","categories":[{"name":"博客","slug":"博客","permalink":"/categories/博客/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"/categories/博客/"}]}]}